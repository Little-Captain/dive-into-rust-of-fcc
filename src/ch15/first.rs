// 内部可变性
// Rust 的 borrow checker 的核心思想是“共享不可变，可变不共享”。
// 只有这个规则是不够的，在某些情况下，的确需要在存在共享的情况下可变。
// 为了让这种情况是可控的、安全的，Rust 设计了一种“内部可变性”(interior mutability)。
// “内部可变性”的概念，是与“承袭可变性”(inherited mutability)相对应的。
// Rust 中的 mut 关键字不能在声明类型的时候使用，只能跟变量一起使用。
// 类型本身不能规定自己是否是可变的。
// 一个变量是否是可变的，取决于它的使用环境，而不是它的类型。
// 可变还是不可变取决于变量的使用方式，这就叫作“承袭可变性”。
// 如果用 let var: T; 声明，那么 var 是不可变的，同时，var 内部的所有成员也都是不可变的；
// 如果用 let mut var: T; 声明，那么 var 是可变的，相应的，它的内部所有成员也都是可变的。
// 不能在类型声明的时候指定可变性，比如在 struct 中对某部分成员使用 mut 修饰，这是不合法的。
// 只能在变量声明的时候指定可变性。也不能针对变量的某一部分成员指定可变性，其他部分保持不变。
// 常见的具备内部可变性特点的类型有 Cell、RefCell、Mutex、RwLock、Atomic* 等。
// 其中 Cell 和 RefCell 是只能用在单线程环境下的具备内部可变性的类型。

// Cell
// 如果有共享引用指向一个对象，那么这个对象就不会被更改了。
// 因为在共享引用存在的期间，不能有可变引用同时指向它，因此它一定是不可变的。
// 其实在 Rust 中，这种理解是不准确的。
pub fn first() {
    // Rc 是 Rust 里面的引用计数智能指针。多个 Re 指针可以同时指向同一个对象，
    // 而且有一个共享的引用计数值在记录总共有多少个 Rc 指针指向这个对象。
    // 注意 Rc 指针提供的是共享引用，按道理它没有修改共享数据的能力。
    // 用共享引用调用 clone 方法，引用计数值会发生变化。这就是“内部可变性”。
    // 如果没有内部可变性，标准库中的 Rc 类型是无法正确实现出来的。
    fn test1() {
        use std::rc::Rc;
        let r1 = Rc::new(1);
        println!("reference count {}", Rc::strong_count(&r1));
        let r2 = r1.clone();
        println!("reference count {}", Rc::strong_count(&r2));
    }
    test1();
    // 具备内部可变性的类型，最典型的就是 Cell。
    fn test2() {
        use std::cell::Cell;
        let data: Cell<i32> = Cell::new(100);
        let p = &data;
        data.set(10);
        println!("{}", p.get());
        p.set(20);
        println!("{:?}", data);
        // 需要注意的是，
        // data 这个变量绑定没有用 mut 修饰，
        // p 这个指针也没有用 &mut 修饰，
        // 然而不可变引用竟然可以调用 set 函数，改变变量的值，
        // 而且还有出现任何编译错误。
        // 这就是所谓的内部可变性，这种类型可以通过共享指针修改它内部的值。
        // Cell 类型似乎违反了 Rust 的“唯一修改权”原则。
        // 存在多个指向 Cell 类型的不可变引用，同时还能利用不可变引用改变 Cell 内部的值。
        // 实际上，这个类型是完全符合“内存安全”的。

        // 为什么 Rust 要尽力避免 alias 和 mutation 同时存在？
        // 假如同时有可变指针和不可变指针指向同一块内存，
        // 有可能出现通过一个可变指针修改内存的过程中，
        // 数据结构处于被破坏状态的情况下，被其他的指针观测到。

        // Cell 类型是不会出现这样的情况的。
        // 因为 Cell 类型把数据包裹在内部，用户无法获得指向内部状态的指针，
        // 这意味着每次方法调用都是执行的一次完整的数据移动操作。
        // 每次方法调用之后，Cell 类型的内部都处于一个正确的状态，不可能观察到数据被破坏掉的状态。

        // Cell 类似一个“壳”，它把数据严严实实地包裹在里面，所有的指针只能指向 Cell，
        // 不能直接指向数据。修改数据只能通过 Cell 来完成，用户无法创造一个直接指向数据的指针。

        // Cell 类型公开的主要 API
        // impl<T> Cell<T> {
        //     pub fn get_mut(&mut self) -> &mut T {}
        //     pub fn set(&self, val: T) {}
        //     pub fn swap(&self, other: &Self) {}
        //     pub fn replace(&self, val: T) -> T {}
        //     pub fn into_inner(self) -> T {}
        // }
        // impl<T: Copy> Cell<T> {
        //     pub fn get(&self) -> T {}
        // }
    }
    test2();
}