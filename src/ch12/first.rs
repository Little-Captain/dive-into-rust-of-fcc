// 借用和生命周期

// 生命周期
// 一个变量的生命周期就是它从创建到销毁的整个过程。
pub fn first() {
    let v = vec![1, 2, 3, 4, 5]; // v 的生命周期开始
    {
        let center = v[2]; // center 的生命周期开始
        println!("{}", center);
    } // center 的生命周期结束
    println!("{:?}", v);
} // v 的生命周期结束
// 如果一个变量永远只能有唯一一个入口可以访问的话，那就太难使用了。
// 因此，所有权还可以借用。

// 所有权借用
// 变量对其管理的内存拥有所有权。这个所有权不仅可以被转移(move)，还可以被借用(borrow)。
// 借用指针的语法使用 & 符号或者 &mut 符号表示。前者表示只读借用，后者表示可读写借用。
// 借用指针(borrow pointer)也可以称作“引用”(reference)。借用指针与普通指针的内
// 部数据是一模一样的，唯一的区别是语义层面上的。它的作用是告诉编译器，它对指向的这
// 块内存区域没有所有权。
// 借用指针在编译后，就是一个普通的指针，它的意义只能在编译阶段的静态检查中体现。
pub fn second() {
    // 形参类型: 可变的借用指针
    fn foo(v: &mut Vec<i32>) {
        // Vec::push 函数的作用是对动态数组添加元素，它的签名是 pub fn push(&mut self, value: T)
        // 它要求 self 参数是一个 &mut Self 类型。
        v.push(5);
    }
    fn test1() {
        // 需要动态数组本身是可变的
        let mut v = vec![];
        // 获取可变借用指针
        foo(&mut v);
        println!("{:?}", v);
    }
    test1();

    // 对于 &mut 型指针，不要混淆它与变量绑定之间的语法。
    // 如果 mut 修饰的是变量名，那么它代表这个变量可以被重新绑定；
    // 如果 mut 修饰的是 “借用指针 &”，那么它代表的是被指向的对象可以被修改。
    fn test2() {
        let mut var = 0;
        {
            // p1 指针本身不能被重新绑定，可以通过 p1 改变变量 var 的值
            let p1 = &mut var;
            *p1 = 1;
        }
        {
            let temp = 2;
            // 不能通过 p2 改变变量 var 的值，但 p2 指针本身指向的位置可以被改变
            let mut p2 = &var;
            p2 = &temp;
        }
        {
            let mut temp = 3;
            // 既可以通过 p3 改变变量 var 的值，
            // 而且 p3 指针本身指向的位置也可以改变
            let mut p3 = &mut var;
            *p3 = 13;
            p3 = &mut temp;
        }
        println!("{}", var);
    }
    test2();
}

// 借用规则
// 关于借用指针，有以下几条规则：
// 1. 借用指针不能比它指向的变量存在的时间更长。
// 2. &mut 型借用只能指向本身具有 mut 修饰的变量，对于只读变量，不可以有 &mut 型借用。
// 3. &mut 型借用指针存在的时候，被借用的变量本身会处于“冻结”状态。
// 4. 如果只有 & 型借用指针，那么能同时存在多个；如果存在 &mut 型借用指针，那么只能存在一个；
// 如果同时有其他的 & 或者 &mut 型借用指针存在，那么会出现编译错误。
// 5. 借用指针只能临时地拥有对这个变量读或写的权限，没有权力管理这个变量的生命周期。
// 因此，借用指针的生命周期绝对不能大于它所引用的原来变量的生命周期，
// 否则就是悬空指针，会导致内存不安全。
pub fn third() {
    // 参数采用的“引用传递”，实参并未丢失对内存的管理权
    fn borrow_semantics(v: &Vec<i32>) {
        // 打印参数占用空间的大小，在 64 位系统上， 结果为 8，
        // 表明该指针与普通裸指针的内部表示方法相同
        println!("size of param: {}", std::mem::size_of::<&Vec<i32>>());
        for item in v {
            print!("{} ", item);
        }
        println!();
    }
    // 参数采用的“值传递”，而 Vec 没有实现 Copy trait，意味着它将执行 move 语义
    fn move_semantics(v: Vec<i32>) {
        // 打印参数占用空间的大小，结果为 24，
        // 表明实参中栈上分配的内存空间复制到了函数的形参中
        println!("size of param: {}", std::mem::size_of::<Vec<i32>>());
        for item in v {
            print!("{} ", item);
        }
        println!();
    }
    fn test1() {
        let array = vec![1, 2, 3, 4, 5];
        // 需要注意的是，如果使用引用传递，不仅在函数声明的地方需要使用 & 标记
        // 函数调用的地方同样需要使用 & 标记，否则会出现语法错误
        // 小数点方式的成员函数调用，对于 self 参数，会“自动转换”，不必显式借用
        borrow_semantics(&array);
        // 在使用引用传递给上面的函数后，array 本身依然有效，还能在下面的函数中使用
        move_semantics(array);
        // 在使用 move 语义传递后，array 在这个函数调用后，它的生命周期就已经完结
    }
    test1();

    // 一般情况下，函数参数使用引用传递的时候，不仅在函数声明这里要写上类型参数，
    // 在函数调用这里也要显式地使用引用运算符。
    // 但是，有一个例外，那就是当参数为 self、&self、&mut self 等时，
    // 若使用小数点语法调用成员方法，在函数调用这里不能显式写出借用运算符。
    fn test2() {
        let mut x: String = "hello".into();
        // len(&self) -> usize
        // 完整调用形式：String::len(&x)
        println!("length of String {}", x.len());
        // push(&mut self, ch: char)
        // 完整调用形式：String::push(&mut x, '!')
        x.push('!');

        println!("length of String {}", x.len());

        // into_bytes(self) -> Vec<u8>
        // 注意 self 的类型，此处发生了所有权转移
        // 完整调用形式：String::into_bytes(x)
        let v = x.into_bytes();

        // 再次调用 len()，编译失败，因为此处已经超过了 x 的生命周期
        // println!("length of String {}", x.len());
    }
    test2();

    // 任何借用指针的存在，都会导致原来的变量被“冻结”(Frozen)。
    /*
    fn test3() {
        let mut x = 1;
        let p = &mut x;
        // 因为 p 的存在，此时对 x 的改变被认为是非法的。
        x = 2;
        println!("value of pointed: {}", p);
    }
    test3();
    */
}

// 生命周期标记
// 对一个函数内部的生命周期进行分析，Rust 编译器可以很好地解决。
// 但是，当生命周期跨函数的时候，就需要一种特殊的生命周期标记符号了。
pub fn fourth() {
    // 函数的生命周期标记
    fn test1() {
        struct T {
            member: i32,
        }
        // 生命周期符号使用单引号开头，后面跟一个合法的名字。
        // 生命周期标记和泛型类型参数是一样的，都需要先声明后使用。
        // 在上面这段代码中，尖括号里面的 'a 是声明一个生命周期参数，
        // 它在后面的参数和返回值中被使用。
        // 在做局部变量的时候，生命周期参数是可以省略的。
        // 生命周期之间有重要的包含关系。如果生命周期 'a 比 'b 更长或相等，则记为 'a : 'b，
        // 对于借用指针类型来说，
        // 如果 &'a 是合法的，那么 'b 作为 'a 的一部分， &'b 也一定是合法的。
        // 'static 是一个特殊的生命周期，它代表的是这个程序从开始到结束的整个阶段，
        // 所以它比其他任何生命周期都长。任意一个生命周期 'a 都满足 'static : 'a。
        fn test<'a>(arg: &'a T) -> &'a i32 {
            &arg.member
        }
        let t = T { member: 0 }; // 't 开始
        // 这条语句实际上是把 &'t i32 类型的变量赋值给 &'x i32 类型的变量。
        // 这个赋值是合理的。因为这两个生命周期的关系是 't: 'x。
        // test 返回的那个指针在 't 这个生命周期范围内都是合法的，
        // 在一个被 't 包围的更小范围的生命周期内，它当然也是合法的。
        let x = test(&t); // 'x 开始
        println!("{:?}", x);
    } // 先 'x 结束，后 't 结束
    // 对于上面的代码，'x 在一个被 't 包围的更小范围的生命周期内，它当然也是合法的。可以编译通过。
    test1();

    // 函数的生命周期标记，示例2
    fn test2() {
        struct T {
            member: i32,
        }
        // 'a: 'b 指定了 'a 的生命周期 >= 'b 的生命周期
        // 如果不指定，'a 和 'b 没有任何关系，编译器会觉得这个赋值是错误的。
        fn test<'a, 'b>(arg: &'a T) -> &'b i32 where 'a: 'b {
            // 'a 比 'b “活”得长，自然，&'a i32 类型赋值给 &'b i32 类型是没问题的
            &arg.member
        }
        let t = T { member: 0 }; // 't 开始
        // 在 test 函数被调用的时候，生命周期参数 'a 和 'b 被分别实例化为了 't 和 'x。
        // 它们刚好满足了 where 条件中的 'a: 'b 约束('t: 'x)。
        // 而 &arg.member 这条表达式的类型是 &'t i32，返回值要求的是 &'x i32 类型，这也是合法的。
        // 所以 test 函数的生命周期检查可以通过。
        let x = test(&t); // 'x 开始
        println!("{:?}", x);
    } // 先 'x 结束，后 't 结束
    test2();

    // 综上
    // fn test<'a>(arg: &'a T) -> &'a i32
    // fn test<'a, 'b>(arg: &'a T) -> &'b i32 where 'a: 'b
    // 这两种写法都是合法的。
    // Rust 的引用类型是支持“协变”的。在编译器看来，生命周期就是一个区间，
    // 生命周期参数就是一个普通的泛型参数，它可以被特化为某个具体的生命周期。

    fn test3() {
        fn select<'a>(arg1: &'a i32, arg2: &'a i32) -> &'a i32 {
            if *arg1 > *arg2 {
                arg1
            } else {
                arg2
            }
        }
        let x = 1; // 'x 开始
        let y = 2; // 'y 开始
        // 分析
        // select 这个函数引入了一个生命周期标记，两个参数以及返回值都是用的这个生命周期标记。
        // 在调用的时候，传递的实参是具备不同的生命周期的。
        // x 的生命周期明显大于 y 的生命周期，&x 可存活的范围要大于 &y 可存活的范围，
        // 把它们的实际生命周期分别记录为 'x 和 'y。
        // select 函数的形式参数要求的是同样的生命周期，而实际参数是两个不同生命周期的引用，
        // 这个类型之所以可以匹配成功，是因为生命周期的协变特性。
        // 编译器可以把 &x 和 &y 的生命周期都缩小到某个生命周期 'a 以内，且满足 'x: 'a, 'y: 'a 。
        // 返回的 selected 变量具备 'a 生命周期，也并没有超过 'x 和 'y 的范围。
        // 所以，最终的生命周期检查可以通过。
        let selected = select(&x, &y);
        println!("{}", selected);
    } // 先 'y 结束，后 'x 结束. 'x: 'y
    test3();

    // 类型的生命周期标记
    // 如果自定义类型中有成员包含生命周期参数，那么这个自定义类型也必须有生命周期参数。
    fn test4() {
        struct T<'a> {
            member: &'a str
        }
        // 在使用 impl 的时候，也需要先声明再使用
        impl<'t> T<'t> {
            fn test<'a>(&self, s: &'a str) {}
        }
        // 若是有 where T: 'static 的约束，意思则是，类型 T 里面不包含任何指向
        // 短生命周期的借用指针，意思是要么完全不包含任何借用，要么可以有指向
        // 'static 的借用指针。
    }
    test4();

    // 省略生命周期标记
    // 在某些情况下，Rust 允许在写函数的时候省略掉显式生命周期标记。在这种时候，编译器会
    // 通过一定的固定规则为参数和返回值指定合适的生命周期，从而省略一些显而易见的生命周期标记。
    fn test5() {
        fn get_str(s: &String) -> &str {
            s.as_ref()
        }
        // 等价于
        fn get_str_x<'a>(s: &'a String) -> &'a str {
            s.as_ref()
        }
        // 这个函数返回的指针将并不指向参数传人的数据，而是指向一个静态常量
        // fn get_str_y(s: &String) -> &str
        // 期望返回的指针是 &'static str 类型,
        // 实际上返回值的生命周期被编译器指定为和输入参数一致
        // 所以这时，不能省略生命周期标记
        // fn get_str_y<'a>(s: &'a String) -> &'static str {
        // 只写返回值的生命周期标记也可
        fn get_str_y(s: &String) -> &'static str {
            println!("call fn {}", s);
            "hello world"
        }
        let c = String::from("hello");
        // error[E0597]: `c` does not live long enough
        let x: &'static str = get_str_y(&c);
        // 按照分析，变量 x 理应指向一个 'static 生命周期的变量，根本不是指向 c 变量，
        // 它的存活时间足够长，为什么编译器没发现这一点呢？
        // 这是因为，编译器对于省略掉的生命周期，不是用的“自动推理“策略，而是用的几个非常简单的
        // “固定规则”策略。这跟类型自动推导不一样，当省略变量的类型时，编译器会试图通过变量的
        // 使用方式推导出变量的类型，这个过程叫 “type inference”。
        // 对于省略掉的生命周期参数，编译器的处理方式就简单粗暴得多，它完全不管函数内部的实现，
        // 并不尝试找到最合适的推理方案，只是应用几个固定的规则，
        // 这些规则被称为 “lifetime elision rules”。
        // 省略的生命周期被自动补全的规则：
        // 1. 每个带生命周期参数的输入参数，每个对应不同的生命周期参数；
        // 2. 如果只有一个输入参数带生命周期参数，那么返回值的生命周期被指定为这个参数；
        // 3. 如果有多个输入参数带生命周期参数，但其中有 &self、&mut self，
        //    那么返回值的生命周期被指定为这个参数；
        // 4. 以上都不满足，就不能自动补全返回值的生命周期参数。
        println!("{}", x);
    }
    test5();
    // 总结，elision != inference，省略 != 推导
    // 省略生命周期参数和类型自动推导的原理是完全不同的。
}
