// 借用和生命周期

// 生命周期
// 一个变量的生命周期就是它从创建到销毁的整个过程。
pub fn first() {
    let v = vec![1, 2, 3, 4, 5]; // v 的生命周期开始
    {
        let center = v[2]; // center 的生命周期开始
        println!("{}", center);
    } // center 的生命周期结束
    println!("{:?}", v);
} // v 的生命周期结束
// 如果一个变量永远只能有唯一一个入口可以访问的话，那就太难使用了。
// 因此，所有权还可以借用。

// 所有权借用
// 变量对其管理的内存拥有所有权。这个所有权不仅可以被转移(move)，还可以被借用(borrow)。
// 借用指针的语法使用 & 符号或者 &mut 符号表示。前者表示只读借用，后者表示可读写借用。
// 借用指针(borrow pointer)也可以称作“引用”(reference)。借用指针与普通指针的内
// 部数据是一模一样的，唯一的区别是语义层面上的。它的作用是告诉编译器，它对指向的这
// 块内存区域没有所有权。
// 借用指针在编译后，就是一个普通的指针，它的意义只能在编译阶段的静态检查中体现。
pub fn second() {
    // 形参类型: 可变的借用指针
    fn foo(v: &mut Vec<i32>) {
        // Vec::push 函数的作用是对动态数组添加元素，它的签名是 pub fn push(&mut self, value: T)
        // 它要求 self 参数是一个 &mut Self 类型。
        v.push(5);
    }
    fn test1() {
        // 需要动态数组本身是可变的
        let mut v = vec![];
        // 获取可变借用指针
        foo(&mut v);
        println!("{:?}", v);
    }
    test1();

    // 对于 &mut 型指针，不要混淆它与变量绑定之间的语法。
    // 如果 mut 修饰的是变量名，那么它代表这个变量可以被重新绑定；
    // 如果 mut 修饰的是 “借用指针 &”，那么它代表的是被指向的对象可以被修改。
    fn test2() {
        let mut var = 0;
        {
            // p1 指针本身不能被重新绑定，可以通过 p1 改变变量 var 的值
            let p1 = &mut var;
            *p1 = 1;
        }
        {
            let temp = 2;
            // 不能通过 p2 改变变量 var 的值，但 p2 指针本身指向的位置可以被改变
            let mut p2 = &var;
            p2 = &temp;
        }
        {
            let mut temp = 3;
            // 既可以通过 p3 改变变量 var 的值，
            // 而且 p3 指针本身指向的位置也可以改变
            let mut p3 = &mut var;
            *p3 = 13;
            p3 = &mut temp;
        }
        println!("{}", var);
    }
    test2();
}

// 借用规则
// 关于借用指针，有以下几个规则：
// q 借用指针不能比它指向的变量存在的时间更长 。
// 0 &mut 型借用只能指向本身具有 mut 修饰的变量，对于只读变量，不可以有 ＆ mut 型
// 借用 。
// 0 &mut 型借用指针存在的时候，被借用的变量本身会处于“冻结” 状态 。
// 0 如果只有＆型借用指针，那么能同时存在多个；如果存在 ＆mut 型借用指针，那么只
// 能存在一个；如果同时有其他的＆或者 ＆ mut 型借用指针存在，那么会出现编译错误 。
// 借用指针只能临时地拥有对这个变量读或写的权限，没有义务管理这个变量的生命周
// 期 。 因此，借用指针的生命周期绝对不能大于它所引用的原来变量的生命周期，否则就是悬
// 空指针，会导致内存不安全 。
pub fn third() {}
