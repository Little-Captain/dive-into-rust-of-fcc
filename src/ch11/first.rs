// 所有权和移动语义

// C++ 对 C 中的手动内存管理进行了一个改进，即通过“智能指针”来描述“所有权”(Ownership)概念。
// 这在一定程度上减少了内存使用 bug，实现了“半自动化”的内存管理。
// Rust 在此基础上更进一步，将“所有权”的理念直接融入到了语言之中。

// “所有权”代表着以下意义：
// 1. 每个值在 Rust 中都有一个变量来管理它，这个变量就是这个值、这块内存的所有者；
// 2. 每个值在一个时间点上只有一个管理者；
// 3. 当变量所在的作用域结束的时候，变量以及它代表的值将会被销毁。
pub fn first() {
    fn test1() {
        // s 为字符串的所有者。mut 代表这个变量是可以可变的
        let mut s = String::from("hello");
        // 调用 String 的成员方法来修改变量
        s.push_str(" world");
        println!("{}", s);
        // 函数结束的时候，s 将会被析构(不论是堆上的，还是栈上的)，它的内存会被释放。
    }
    test1();

    /*
    // 编译报错
    fn test2() {
        let s = String::from("hello");
        let s1 = s;
        // 编译器显示，在 let s1 = s; 语句中，原本由 s 拥有的字符串
        // 已经转移给了 s1 这个变量。所以，后面继续使用 s 是不对的。
        // 也就是说每个值只有一个所有者。
        // 变量 s 的生命周期从声明开始，到 move 给 s1 就结束了。
        // 变量 s1 的生命周期则是从它声明开始，到函数结束。
        // 由 String::from 函数创建出来的字符串本身，到函数结束的时候就会销毁。
        // 中间所有权的转换，并不会将这个字符串本身销毁再重新创建。
        // 在任意时刻，这个字符串只有一个所有者，要么是 s，要么是 s1。
        println!("{}", s);
    }
    test2();
    */

    fn test3() {
        let s = String::from("hello");
        // 手动调用 clone 方法，进行“深复制”
        let s1 = s.clone();
        println!("{} {}", s, s1);
    }
    test3();
}