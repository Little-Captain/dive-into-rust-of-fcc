pub fn def_variable() {
    let variable: i32 = 100;
    println!("var = {}", variable);
    // let 语句在此处引入了一个模式解构, 不能把 let mut 视为一个组合
    // 而应该将 mut x 视为一个组合
    let mut x = 5;
    x = 10;
    println!("x = {}", x);
    // mut x 是一个"模式", 可以用这种方式同时声明多个变量
    let (mut a, mut b) = (1, 2);
    a = 12;
    b = 13;
    println!("a = {} b = {}", a, b);
    // 在 Rust 中, 一般把声明的局部变量并初始化的语句称为"变量绑定"
    // 强调的是"绑定"的含义, 与 C/C++ 中的"赋值初始化"语句有所区别

    // Rust 中, 每个变量必须被合理初始化之后才能被使用, 使用未初始化变量这样的错误
    // 在 Rust 中是不可能出现的(利用 unsafe 做 hack 除外)
    test(true);
    // 类型没有"默认构造函数", 变量没有"默认值"

    // Rust 里面的下划线是一个特殊的标识符, 在编译器内部它是被特殊处理的
    // 它跟其他标识符有许多重要区别
    // 不能只使用下划线做标识符
    // let _ = "hello";
    // println!("{}", _);
    // 下划线表达的含义是"忽略这个变量绑定, 后面不会再用到了"
}

fn test(condition: bool) {
    let x: i32; // 声明 x, 不必使用 mut 修饰
    if condition {
        x = 1; // 初始化 x, 不需要 x 是 mut 的, 因为这是初始化, 不是修改
        println!("{}", x);
    }
    // 如果条件不满足, x 没有被初始化
    // 但是没关系, 只要这里不使用 x 就没事
}

pub fn shadowing_var() {
    // Rust 允许在同一个代码块中声明同样名字的变量
    // 后面声明的变量会将前面声明的变量"遮蔽"(Shadowing)起来
    let x = "hello";
    println!("x is {}", x);

    let x = 5;
    println!("x is {}", x);
}

// 一个"不可变绑定"依然是一个"变量"
// 虽然没办法通过这个"变量绑定"修改变量的值, 但是重新使用"可变绑定"之后, 还是有机会修改的
// 这样做并不会产生内存安全问题, 因为我们对这块内存拥有完整的所有权, 且此时没有任何其他引用
// 指向这个变量, 对这个变量的修改是完全合法的. Rust 的可变性控制规则与其他语言不一样
// 实际上, 传统编程语言 C/C++ 中也存在类似的功能, 只不过它们只允许嵌套的区域内部的变量出现遮蔽
// 而 Rust 在这方面放得稍微宽一点, 同一个语句块内部声明的变量也可以发生遮蔽
pub fn shadowing_var1() {
    // 变量遮蔽的一种用法
    // 对一个可变数组执行初始化, 希望此时它是可读写的, 但是初始化完成后, 我们希望它是只读的
    let mut v = Vec::new(); // v 必须是 mut 修饰, 因为我们需要对它写入数据
    v.push(1);
    v.push(2);
    v.push(3);
    v.push(4);

    let v = v; // 从这里往下, v 成了只读变量, 可读写变量 v 已经被遮蔽, 无法再访问
    for i in &v {
        println!("{}", i);
    }

    // 反过来, 如果一个变量是不可变的, 我们也可以通过变量遮蔽创建一个新的、可变的同名变量
    let v = Vec::new();
    let mut v = v;
    v.push(1);
    println!("{:?}", v);
}