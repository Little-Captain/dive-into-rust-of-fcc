// macro
pub fn first() {
    // “宏”（macro）是 Rust 的一个重要特性。
    // Rust 的“宏”（macro 是一种编译器扩展，它的调用方式为 some_macro!(…)。
    // 宏调用与普通函数调用的区别可以一眼区分开来，凡是宏调用后面都跟着一个感叹号。
    // 宏也可以通过 some_macro![…]和 some_macro!{…}两种语法调用，只要括号能正确匹配即可

    // 与 C/C++ 中的宏的区别
    // 首先，Rust 的宏在调用的时候跟函数有明显的语法区别；
    // 其次，宏的内部实现和外部调用者处于不同名字空间，它的访问范围严格受限，
    // 是通过参数传递进去的，不能随意在宏内访问和改变外部的代码。
    // C/C++ 中的宏只在预处理阶段起作用，只能实现类似文本替换的功能。
    // Rust 中的宏在语法解析之后起作用，可以获取更多的上下文信息，而且更加安全。

    // 可以把“宏”视为“元编程”的一种方式。它是一种“生成程序的程序”

    // 实现编译阶段检查
    fn test1() {
        // 下面的代码会编译失败。就是通过宏实现的编译阶段检查
        // println!("number {} number {}");
        // 使用宏，可以在编译阶段分析这个字符串常量和对应参数，确保它符合约定。
        // 另外一个常见的场景是，利用宏来检查正则表达式的正确性。
    }
    test1();

    // 实现编译器计算
    fn test2() {
        // 打印出当前源代码的文件名，以及当前代码的行数。这些信息是纯编译阶段的信息
        println!("file {} line {}", file!(), line!());
    }
    test2();

    // 实现自动代码生成

    // 实现语法扩展
    // 可以使用宏来设计比较方便的“语法糖”
    fn test3() {
        let v = vec![1, 2, 3, 4, 5];
        println!("{:?}", v);
    }
    test3();
}

// 示范型宏
pub fn second() {
    // 自定义宏的两种方式
    // 1. 通过标准库提供的 macro_rules! 宏实现
    // 2. 通过提供编译器扩展来实现

    // macro_rules! 是标准库中提供的一个编写简单宏的小工具，
    // 它本身也是用编译器扩展来实现的。它可以提供一种“示范型”(by example)宏编写方式
    // let counts = hashmap!['A' => 0, 'C' => 0];
    // 在大括号里面，定义宏的使用语法，以及它展开后的形态。
    // 定义方式类似 match 语句的语法， expander => { transcriber }。
    // 左边的是宏扩展的语法定义，后面是宏扩展的转换机制。
    // 语法定义的标识符以 $ 开头，类型支持 item、block、stmt、pat、expr、ty、itent、path、tt。
    // 在宏里面，可以支持重复多个语法元素。类似正则表达式的概念，+ 模式代表一个或者多个重复，
    // * 模式代表零个或者多个重复。要把需要重复的部分用括号括起来，并加上逗号分隔符
    // 需求是需要一个表达式，一个“=>”标识符，再跟一个表达式
    macro_rules! hashmap {
        ($( $key: expr => $val: expr ), *) => {{
            {
                let mut map = std::collections::HashMap::new();
                // 在语法扩展的部分也使用 * 符号，将输入部分扩展为多条 insert 语句
                $( map.insert($key, $val); ) *;
                map
            }
        }}
    }
    let counts = hashmap!['A' => 0, 'C' => 0, 'G' => 0, 'T' => 0];
    println!("{:?}", counts);
    // 确定宏展开是否正确：需要在 nightly compiler 中使用
    // rustc -Z unstable-options --pretty=expanded scr/ch09/first.rs temp.rs
}

// 过程宏
pub fn third() {
    // 它直接用 Rust 语言编写相当于一个编译器插件。
    // 但是编译器插件的最大问题是，它依赖于编译器的内部实现方式。
    // 一旦编译器内部有所变化，那么对应的宏就有可能出现编译错误
    // 因此 Rust 中的“宏”一直难以稳定
    // ...
}
