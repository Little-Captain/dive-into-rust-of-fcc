// 借用检查

// Rust 实现了无性能损失的“内存安全”
// Rust 语言的核心特点是：在没有放弃对内存的直接控制力的情况下，实现了内存安全。
// 所谓对内存的直接控制能力，即可以自行决定内存布局，包括在栈上分配内存，
// 和在堆上分配内存；支持指针类型；可以对一个变量实施取地址操作；
// 有确定性的内存释放；等等。
// 另一方面，从安全性的角度来说，可以看到，
// Rust 有所有权概念、借用指针、生命周期分析等这些内容。
// Rust 语言的这一系列安全规则，背后的指导思想是什么呢？
// 总的来说，Rust 的设计者们在一系列的“内存不安全”的问题中观察到了一个结论：
// Danger arise from Aliasing + Mutation
// 1. Alias 的意思是“别名”。
//    如果一个变量可以通过多种 Path 来访问，那它们就可以互相看作 alias。
//    Alias 意味着“共享”，即有多个入口可以访问同一块内存。
// 2. Mutation 的意思是“改变”。如果通过某个变量修改了一块内存，就是发生了 mutation。
//    Mutation 意味着拥有“修改”权限，即可以写入数据。
// Rust 保证内存安全的一个重要原则就是，
// 如果能保证 alias(共享性) 和 mutation(可变性) 不同时出现，那么代码就一定是安全的。
// 一言以蔽之：共享不可变，可变不共享
pub fn first() {}

// 编译错误示例
pub fn second() {
    // 正确示例
    // 存在“共享”，不存在“可变”
    fn test1() {
        let i = 0;
        let p1 = &i;
        let p2 = &i;
        println!("{} {} {}", i, p1, p2);
    }
    test1();

    // 编译失败
    // 同时存在“共享”、“可变”
    // error: cannot assign to `i` because it is borrowed
    /*
    fn test2() {
        let mut i = 0;
        let p1 = &i;
        i = 1;
        println!("{}", i);
        // 存在这行代码才出现编译失败，可能是因为未使用变量被编译器优化了
        println!("{}", *p1);
    }
    test2();
    */

    // 正确示例
    // 这段代码中不存在“共享”。
    // 在可变借用存在的时候，编译器认为原来的变量绑定 i 已经被冻结(frozen),
    // 不可通过 i 读写变量。此时有且仅有 p1 这一个入口可以读写变量。
    fn test3() {
        let mut i = 0;
        let p1 = &mut i;
        *p1 = 2;
        println!("{}", *p1);
        let x = i; // 可正常编译通过，可能是编译器改变了。
        println!("{}", x);
    }
    test3();

    // 不可以创建两个可变借用指针
    // &mut 型借用被称为“独占指针”， & 型借用被称为“共享指针”。
    /*
    fn test4() {
        let mut i = 0;
        let p1 = &mut i;
        let p2 = &mut i;
        *p1 = 1;
        *p2 = 2;
    }
    test4();
    */
}

// 内存不安全示例：修改枚举
pub fn third() {
    #[derive(Debug)]
    enum StringOrInt {
        Str(String),
        Int(i64),
    }

    fn test1() {
        use StringOrInt::{Str, Int};
        let mut x = Str("Hello World".to_string());
        // 用 if let 语法创建了一个指向内部 String 的指针，
        // 然后在此指针的生命周期内，再把 x 内部数据变成 i64 类型。
        // error: cannot assign to `x` because it is borrowed
        /*
        if let Str(ref insides) = x {
            x = Int(1);
            println!("inside is {}, x says: {:?}", insides, x);
        }
        */
    }
    test1();
}

// 内存不安全示例：迭代器失效
// 在遍历一个数据结构的过程中修改这个数据结构，会导致迭代器失效
pub fn fourth() {
    fn test1() {
        let mut arr = vec!["ABC", "DEF", "GHI"];
        // error: cannot borrow `arr` as mutable because
        //        it is also borrowed as immutable
        // Rust 里面的 for 循环生成了一个迭代器，它一直持有一个指向容器的引用，
        // 在迭代器的生命周期内，任何对容器的修改都是无法编译通过的。
        for item in &arr {
            // arr.clear();
            println!("{}", item);
        }
        // 在整个 for 循环的范围内，这个迭代器的生命周期都一直存在。而它持有一个指向容器的引用，
        // & 型或者 &mut 型，视情况而定。
        // 迭代器的 API 设计使得可以修改当前指向的元素，而没法修改容器本身。
        // 当想在这里对容器进行修改的时候，必然需要产生一个新的针对容器的 &mut 型引用，
        // (clear 方法的签名是 Vec::clear(&mut self)，调用 clear 必然产生对原 Vec 的
        // &mut 型引用)。这与 Rust 的 "alias+mutation" 规则相冲突的，所以编译不通过。
        // "alias+mutation" 规则的核心思路：
        // 如果存在多个只读的引用，是允许的；如果存在可写的引用，
        // 那么就一定不能同时存在其他的只读或者可写的引用。
        // Rust 检查内存安全的核心逻辑可以理解为一个在编译阶段执行的读写锁。
        // 多个读同时存在是可以的，存在一个写的时候，其他的读写都不能存在。
        // Rust 设计者总结的 Rust 的三大特点： 一是快，二是内存安全，三是免除数据竞争。
        // Rust 所谓的“免除数据竞争”，实际上和“内存安全”是一回事。
        // “免除数据竞争”可以看作多线程环境下的“内存安全”。
        // 单线程环境下的“肉存安全”靠的是编译阶段的类似读写锁的机制，
        // 与多线程环境下其他语言常用的读写锁机制并无太大区别。
        // 正是因为 Rust 编译器在设计上打下的良好基础，
        // “内存安全”才能轻松地扩展到多线程环境下的“免除数据竞争”。
    }
    test1();
}

// 内存不安全示例： 悬空指针
pub fn fifth() {
    // 使用动态数组类型，使用一个指针指向它的第一个元素，
    // 然后在原来的动态数组中插入数据
    /*
    fn test1() {
        let mut arr: Vec<i32> = vec![1, 2, 3, 4, 5];
        let p = &arr[0];
        for i in 1..100 {
            // error: cannot borrow `arr` as mutable because
            //        it is also borrowed as immutable
            // p 在后面的代码不使用，不会触发这条编译错误。
            // 在存在一个不可变指针的情况下，不能修改原来变量的值。
            arr.push(i);
        }
        println!("{:?}", arr);
        let i = *p;
        println!("{}", i);
    }
    test1();
    */
}

// 总结
// Rust 在内存安全方面的设计方案的核心思想是“共享不可变，可变不共享”。
// 在可变性控制方面，如果说，C 语言和函数式编程语言分属一个天平的两端，
// 那么 Rust 就处于这个天平的中央。
// C 语言的思想是：尽量不对程序员做限制，尽量接近机器底层，类型安全、
// 可变性、共享性都由程序员自由掌控，语言本身不提供太多的限制和规定。
// 安全与否，也完全取决于程序员。
// 函数式编程的思想是：尽量使用不可变绑定，在可变性上有严格限制，
// 在共享性方面没有限制。函数式编程特别强调无副作用的函数以及不可变类型，
// 以此来达到提高安全性的目的。
// Rust 选择了折中的方案，既允许可变性，也允许共享性，只要这两者不同时出现即可。
// “共享不可变，可变不共享”，是 Rust 保证内存安全和线程安全的“法宝”。
// Rust 的这个设计并不是首鼠两端、和稀泥式的中庸之道，而是经过了仔细的观察总结、
// 严谨的设计之后的产物。
// 其一，相比函数式设计方式，Rust 并没有本质上牺牲安全性。
//      函数式编程强调的是“不可变性”，极大地提升了安全性的同时也极大地提高了学习门槛。
//      Rust 在“不可变性”的要求上, 做了理性妥协，实现了在不损失安全性的同时，一定程度上也降低了学习成本。
//      从 C/C++ 背景转为使用 Rust 无需做太大的思维转变。相比函数式的设计方式，Rust 的人门门槛更低。
// 其二，Rust 针对传统 C/C++ 做了大幅改进，设计了一系列静态检查规则，来防止一些潜在的 bug。
//      “共享不可变，可变不共享”就是其中一项重要的规则。在传统的 C/C++ 中，所有的指针都是同一个类型。
//      从功能性来说，这样设计是非常强大的，但缺少一定程度的取舍，以提高安全性。
//      相对来说，Rust 对程序员的限制更多，有所为、有所不为。
// 其三，Rust 的内存安全体系，不需要依赖 GC。虽然现在 GC 的性能越来越好，
//      但是没有 GC 在某些场景下依然是很重要的。没有 GC、编译型语言的特点，是 Rust 执行性能的潜力保证。
//      另外，没有 GC 就可以使得它只依赖一个非常轻量级的 runtime。
//      理论上来说，它可以用于许多嵌入式平台，甚至可以在无操作系统的裸机上执行，使用 Rust 编写操作系统也是完全可行的。
//      这就使得 Rust 拥有与 C/C++ 相似的系统级编程特性，大幅扩展了 Rust 的应用场景。
// 其四，Rust 的核心思想“共享不可变，可变不共享”，具有极好的一致性和扩展性。
//      它不仅可以解决内存安全的问题，还是解决线程安全的基础。
//      所谓的线程安全，实质上就是内存安全在多线程情况下的自然延伸。
//      也可以把 Rust 的内存安全解决方案视为传统的线程安全机制 Read Write Locker 在编译阶段执行的版本。
//      如果多个线程对同一个共享变量都是只读的，它是安全的；如果有一个线程对共享变量写操作，那它就必须是独占的，
//      不可有其他线程继续读写，否则就会出现数据竞争。
// Rust 在安全性方面的设计是独一无二的。只要保证了“共享不可变，可变不共享”，就可以保证内存安全。
